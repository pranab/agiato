Agiato is a simple no frill Cassandra NOSQL database API. My goal has been to make sure that
it does not take someone more than hour to learn the API and start using it.

It DOES the following
---------------------

- Supports Cassandra version .7x
- Simple wrapper around thrift API
- API does not support different data types. 
- An Util class is provided for conversion between ByteBuffer and basic data types, which the client app may use
- API only understands ByteBuffer
- The whole API is defined in one class
- There is database connection pooling using appache commons pool library
- There is a simple round robin load balancer, out of the box.
- User defined load balancer can be plugged in
- There is JSON file that defines cluster, connection configuration and key space definition
- The API loads the JSON on start up and creates the key space if necessary
- The client app needs to make sure cassandra.json file is placed in the class path

The API DOES NO DO the following
--------------------------------

- Object mapping
- Data type support

It WILL DO the following in future
----------------------------------

- Support named query and index defined in the JSON file

Setup
-----

Here is a sample cassandra.json file. You should change the content to meet your need. Agiato expects this file in the class
path.

{
    "cluster" :
	{
		"hosts" :
		[
			{
				"name" : "localhost",
				"port" : 9160
			}
		],
		"loadBalancerClass" : "agiato.cassandra.connect.RoundRobinLoadBalancer",
		"poolConfig" : 
		{
			"maxActive" : 8,
			"maxIdle" : 8
		}
	},
	"keySpace" :
	{
		"name" : "PatientMonitor",
		"replicaPlacementStrategy" : "org.apache.cassandra.locator.SimpleStrategy",
		"replicationFactor" : 1,
		"endPointSnitch" : "org.apache.cassandra.locator.EndPointSnitch",
		"columnFamilies" : 
		[
			{
				"name" : "MonitorData",
				"columnType" : "Super",
				"compareWith" : "LongType",
				"compareSubcolumnsWith" : "UTF8Type", 
				"keysCached" : 1000,
				"rowsCached" : 10
			},
			{
				"name" : "Patient",
				"columnType" : "Standard",
				"compareWith" : "UTF8Type",
				"keysCached" : 100,
				"rowsCached" : 10
			}

		]
	}
}

Example client code
-------------------

//when your app starts
DataManager.initialize(false);

//insert a super column into MonitorData column family
DataAccess dataAccess = new DataAccess();
List<SuperColumnValue> superColValues = new ArrayList<SuperColumnValue>();

long rowKey = ...
long superColName = ...
List<ColumnValue> colValues = new ArrayList<ColumnValue>();
ColumnValue colVal = new ColumnValue();
colVal.write("ecg", getEcg());
colValues.add(colVal);

colVal = new ColumnValue();
colVal.write("diaBp", getDiaBp());
colValues.add(colVal);

colVal = new ColumnValue();
colVal.write("sysBp", getSysBp());
colValues.add(colVal);

colVal = new ColumnValue();
colVal.write("temp", getTemp());
colValues.add(colVal);

colVal = new ColumnValue();
colVal.write("pulse", getPulse());
colValues.add(colVal);

SuperColumnValue superColVal = new SuperColumnValue();
superColVal.setNameFromLong(superColName);
superColVal.setValues(colValues);
superColValues.add(superColVal);

dataAccess.insertSuperColumns("MonitorData", rowKey, superColValues, ConsistencyLevel.ALL);



